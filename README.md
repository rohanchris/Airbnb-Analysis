# Airbnb-Analysis
Importing Required Libraries:
import pandas as pd
import streamlit as st
from streamlit_option_menu import option_menu
pd.set_option('display.max_columns', None)
import plotly.express as px
import warnings
warnings.filterwarnings("ignore")
import plotly.graph_objects as go
import seaborn as sns
import matplotlib.pyplot as plt
from PIL import Image
pandas (pd): A powerful data manipulation and analysis library, often used for handling structured data (like CSV files or SQL tables).
streamlit (st): A library for creating web apps quickly and easily, particularly for data science and machine learning projects.
streamlit_option_menu: A module that provides an option menu widget in Streamlit, allowing users to select different options in the app.
plotly.express (px): A module from the Plotly library that provides a simple syntax for creating a wide variety of interactive plots.
warnings: A built-in Python module used to control the warning messages that are displayed during execution.
plotly.graph_objects (go): Another module from the Plotly library used for creating more complex and customizable visualizations.
seaborn (sns): A data visualization library based on matplotlib, providing a high-level interface for drawing attractive statistical graphics.
matplotlib.pyplot (plt): A widely used plotting library in Python for creating static, animated, and interactive visualizations.
PIL.Image: A module from the Python Imaging Library (PIL) for opening, manipulating, and saving images.

Setting Display Options:
pd.set_option('display.max_columns', None)
This line ensures that when displaying dataframes in pandas, all columns will be shown, even if there are many columns. It prevents truncation of columns in the output.

Ignoring Warnings:
warnings.filterwarnings("ignore")
This line suppresses warning messages that might otherwise clutter the output. It’s often used in scripts where known, non-critical warnings are expected and don’t need to be shown.

Usage in Applications:
Streamlit (st): Used for developing interactive web applications with ease. It allows you to create UI components like buttons, sliders, and text input fields, and to display data and plots.
Plotly and Seaborn: Used for data visualization. Plotly provides interactive plots that users can hover over or zoom in on, while Seaborn is often used for more static, publication-quality plots.
Matplotlib: Often used for customizing plots generated by Seaborn or for creating plots from scratch.
PIL.Image: Used for handling image files, which might be displayed in the Streamlit app.

 Setting Up the Streamlit Page:
 st.set_page_config(layout= "wide")
 st.title("AIRBNB DATA ANALYSIS")
 st.write("")
st.set_page_config(layout="wide"): Configures the page layout to be "wide", allowing more content to be displayed horizontally across the screen.
st.title("AIRBNB DATA ANALYSIS"): Sets the title of the web app as "AIRBNB DATA ANALYSIS".
st.write(""): Adds a blank line, often used for spacing purposes.

Loading the Data:
def datafr():
    df = pd.read_csv("C:/Users/dell/Airbnb Analysis/Airbnb.csv")
    return df
df = datafr()
datafr(): A function that reads the Airbnb data from a CSV file located at "C:/Users/dell/Airbnb Analysis/Airbnb.csv" and returns it as a DataFrame.
df = datafr(): Calls the datafr() function and stores the DataFrame in the variable df.

Creating a Sidebar Menu:
with st.sidebar:
    select = option_menu("Main Menu", ["Home", "Data Exploration", "About"])
st.sidebar: Creates a sidebar on the left side of the web app.
option_menu("Main Menu", ["Home", "Data Exploration", "About"]): Adds an option menu in the sidebar with three menu items: "Home", "Data Exploration", and "About". The selected menu item is stored in the select variable.

Displaying Content Based on the Menu Selection:
if select == "Home":
    ImageA = Image.open("C:/Users/dell/Airbnb Analysis/Airbnb.jpeg")
    st.image(ImageA)

    st.header("About Airbnb")
    st.write("")
    st.write('''Airbnb is an online marketplace that connects people who want to rent out
              their property with people who are looking for accommodations, 
              typically for short stays...''')
    
    st.header("Background of Airbnb")
    st.write("")
    st.write('''Airbnb was born in 2007 when two Hosts welcomed three guests to their
              San Francisco home...''')
if select == "Home":: Checks if the user has selected the "Home" option from the sidebar.
Image.open("C:/Users/dell/Airbnb Analysis/Airbnb.jpeg"): Loads an image from the specified file path.
st.image(ImageA): Displays the loaded image on the page.
st.header("About Airbnb"): Adds a header titled "About Airbnb" to the page.
st.write('''...'''): Displays multi-line text with detailed information about Airbnb. The text provides an introduction to Airbnb, its services, and its background.
st.header("Background of Airbnb"): Adds another header titled "Background of Airbnb".
st.write('''...'''): Displays the background information about how Airbnb was founded and its growth over the years.

 Setting Up Tabs:
 if select == "Data Exploration":
    tab1, tab2, tab3, tab4, tab5 = st.tabs(["***PRICE ANALYSIS***", "***AVAILABILITY ANALYSIS***", "***LOCATION BASED***", "***GEOSPATIAL VISUALIZATION***", "***TOP CHARTS***"])
st.tabs([...]): Creates a tabbed interface within the "Data Exploration" section, allowing users to switch between different tabs such as "PRICE ANALYSIS," "AVAILABILITY ANALYSIS," and so on. Each tab represents a different type of data exploration.

Tab 1: PRICE ANALYSIS
Within the first tab, titled "PRICE ANALYSIS," the code provides a detailed exploration of price differences based on various factors.

Tab Title and Layout:
with tab1:
    st.title("**PRICE DIFFERENCE**")
    col1, col2 = st.columns(2)
st.title("**PRICE DIFFERENCE**"): Sets the title for the first tab.
st.columns(2): Divides the tab into two columns (col1 and col2) to organize the content side by side.

Column 1: Analysis by Country, Room Type, and Property Type:
with col1:
    country = st.selectbox("Select the Country", df["country"].unique())
    df1 = df[df["country"] == country]
    df1.reset_index(drop=True, inplace=True)

    room_ty = st.selectbox("Select the Room Type", df1["room_type"].unique())
    df2 = df1[df1["room_type"] == room_ty]
    df2.reset_index(drop=True, inplace=True)

    df_bar = pd.DataFrame(df2.groupby("property_type")[["price", "review_scores", "number_of_reviews"]].sum())
    df_bar.reset_index(inplace=True)

    fig_bar = px.bar(df_bar, x='property_type', y="price", title="PRICE FOR PROPERTY_TYPES",
                     hover_data=["number_of_reviews", "review_scores"],
                     color_discrete_sequence=px.colors.sequential.Redor_r, width=600, height=500)
    st.plotly_chart(fig_bar)
st.selectbox("Select the Country", df["country"].unique()): Allows the user to select a country from the available options in the dataset.
df1 = df[df["country"] == country]: Filters the dataset to only include data for the selected country.
room_ty = st.selectbox("Select the Room Type", df1["room_type"].unique()): Allows the user to select a room type from the filtered dataset.
df2 = df1[df1["room_type"] == room_ty]: Further filters the dataset based on the selected room type.
df_bar = pd.DataFrame(...): Groups the data by property_type and sums up the price, review_scores, and number_of_reviews for each type.
fig_bar = px.bar(...): Creates a bar chart showing the total price for each property type, with additional information on review scores and the number of reviews. The chart is displayed in the first column.

Column 2: Analysis by Property Type and Host Response Time:
with col2:
    st.write("")
    proper_ty = st.selectbox("Select the Property_type", df2["property_type"].unique())
    df4 = df2[df2["property_type"] == proper_ty]
    df4.reset_index(drop=True, inplace=True)

    df_pie = pd.DataFrame(df4.groupby("host_response_time")[["price", "bedrooms"]].sum())
    df_pie.reset_index(inplace=True)

    fig_pi = px.pie(df_pie, values="price", names="host_response_time",
                    hover_data=["bedrooms"],
                    color_discrete_sequence=px.colors.sequential.BuPu_r,
                    title="PRICE DIFFERENCE BASED ON HOST RESPONSE TIME",
                    width=600, height=500)
    st.plotly_chart(fig_pi)
proper_ty = st.selectbox("Select the Property_type", df2["property_type"].unique()): Allows the user to select a property type from the filtered dataset.
df4 = df2[df2["property_type"] == proper_ty]: Further filters the dataset based on the selected property type.
df_pie = pd.DataFrame(...): Groups the data by host_response_time and sums up the price and bedrooms for each response time.
fig_pi = px.pie(...): Creates a pie chart showing the distribution of price based on host response time, with additional information on the number of bedrooms. The chart is displayed in the second column.

Additional Analysis in New Columns:
col1, col2 = st.columns(2)

with col1:
    hostresponsetime = st.selectbox("Select the host_response_time", df4["host_response_time"].unique())
    df5 = df4[df4["host_response_time"] == hostresponsetime]

    df_do_bar = pd.DataFrame(df5.groupby("bed_type")[["minimum_nights", "maximum_nights", "price"]].sum())
    df_do_bar.reset_index(inplace=True)

    fig_do_bar = px.bar(df_do_bar, x='bed_type', y=['minimum_nights', 'maximum_nights'],
                        title='MINIMUM NIGHTS AND MAXIMUM NIGHTS',
                        hover_data="price",
                        barmode='group',
                        color_discrete_sequence=px.colors.sequential.Rainbow,
                        width=600, height=500)

    st.plotly_chart(fig_do_bar)
hostresponsetime = st.selectbox("Select the host_response_time", df4["host_response_time"].unique()): Allows the user to select a host response time.
df5 = df4[df4["host_response_time"] == hostresponsetime]: Further filters the dataset based on the selected host response time.
df_do_bar = pd.DataFrame(...): Groups the data by bed_type and sums up the minimum_nights, maximum_nights, and price for each bed type.
fig_do_bar = px.bar(...): Creates a grouped bar chart showing the minimum and maximum nights for each bed type. The chart is displayed in the first column.

Column 2: Bedrooms and Beds Analysis:
with col2:
    st.write("")
    df_do_bar_2 = pd.DataFrame(df5.groupby("bed_type")[["bedrooms", "beds", "accommodates", "price"]].sum())
    df_do_bar_2.reset_index(inplace=True)

    fig_do_bar_2 = px.bar(df_do_bar_2, x='bed_type', y=['bedrooms', 'beds', 'accommodates'],
                          title='BEDROOMS AND BEDS ACCOMMODATES',
                          hover_data="price",
                          barmode='group',
                          color_discrete_sequence=px.colors.sequential.Rainbow_r,
                          width=600, height=500)
    st.plotly_chart(fig_do_bar_2)
df_do_bar_2 = pd.DataFrame(...): Groups the data by bed_type and sums up the bedrooms, beds, accommodates, and price for each bed type.
fig_do_bar_2 = px.bar(...): Creates a grouped bar chart showing the number of bedrooms, beds, and accommodates for each bed type. The chart is displayed in the second column.

Tab 2: Availability Analysis
This tab analyzes the availability of Airbnb listings across different time frames (30, 60, 90, and 365 days).

Loading Data and Setting Up the Layout:
with tab2:
    def datafr():
        df_a = pd.read_csv("C:/Users/dell/Airbnb Analysis/Airbnb.csv")
        return df_a
     
    df_a = datafr()

    st.title("AVAILABILITY ANALYSIS")
    col1, col2 = st.columns(2)
datafr() Function: Loads the Airbnb dataset from the specified file path.
st.title("AVAILABILITY ANALYSIS"): Sets the title for the second tab.
st.columns(2): Creates two columns (col1 and col2) to structure the content side by side.

Column 1: Sunburst Chart for 30-Day Availability:
with col1:
    country_a = st.selectbox("Select the Country_a", df_a["country"].unique())
    df1_a = df[df["country"] == country_a]
    df1_a.reset_index(drop=True, inplace=True)

    property_ty_a = st.selectbox("Select the Property Type", df1_a["property_type"].unique())
    df2_a = df1_a[df1_a["property_type"] == property_ty_a]
    df2_a.reset_index(drop=True, inplace=True)

    df_a_sunb_30 = px.sunburst(df2_a, path=["room_type", "bed_type", "is_location_exact"], values="availability_30",
                               width=600, height=500, title="Availability_30",
                               color_discrete_sequence=px.colors.sequential.Peach_r)
    st.plotly_chart(df_a_sunb_30)
st.selectbox("Select the Country_a", df_a["country"].unique()): Allows users to select a country from the dataset.
df1_a = df[df["country"] == country_a]: Filters the dataset to include only the selected country.
st.selectbox("Select the Property Type", df1_a["property_type"].unique()): Allows users to select a property type.
df2_a = df1_a[df1_a["property_type"] == property_ty_a]: Filters the dataset further based on the selected property type.
px.sunburst(...): Creates a sunburst chart to visualize the availability of listings for 30 days, grouped by room_type, bed_type, and is_location_exact.

Column 2: Sunburst Chart for 60-Day Availability:
with col2:
    st.write("")
    df_a_sunb_60 = px.sunburst(df2_a, path=["room_type", "bed_type", "is_location_exact"], values="availability_60",
                               width=600, height=500, title="Availability_60",
                               color_discrete_sequence=px.colors.sequential.Blues_r)
    st.plotly_chart(df_a_sunb_60)
px.sunburst(...): Creates another sunburst chart for 60-day availability using the same filtering process as above.

Additional Sunburst Charts for 90 and 365-Day Availability:
col1, col2 = st.columns(2)

with col1:
    df_a_sunb_90 = px.sunburst(df2_a, path=["room_type", "bed_type", "is_location_exact"], values="availability_90",
                               width=600, height=500, title="Availability_90",
                               color_discrete_sequence=px.colors.sequential.Aggrnyl_r)
    st.plotly_chart(df_a_sunb_90)

with col2:
    df_a_sunb_365 = px.sunburst(df2_a, path=["room_type", "bed_type", "is_location_exact"], values="availability_365",
                                width=600, height=500, title="Availability_365",
                                color_discrete_sequence=px.colors.sequential.Greens_r)
    st.plotly_chart(df_a_sunb_365)
df_a_sunb_90 and df_a_sunb_365: Sunburst charts for 90-day and 365-day availability, respectively, using similar filtering and visualization techniques.

Grouped Bar Chart for Availability Based on Host Response Time:
roomtype_a = st.selectbox("Select the Room Type_a", df2_a["room_type"].unique())
df3_a = df2_a[df2_a["room_type"] == roomtype_a]

df_mul_bar_a = pd.DataFrame(df3_a.groupby("host_response_time")[["availability_30", "availability_60", "availability_90", "availability_365", "price"]].sum())
df_mul_bar_a.reset_index(inplace=True)

fig_df_mul_bar_a = px.bar(df_mul_bar_a, x='host_response_time', y=['availability_30', 'availability_60', 'availability_90', "availability_365"],
                          title='AVAILABILITY BASED ON HOST RESPONSE TIME', hover_data="price",
                          barmode='group', color_discrete_sequence=px.colors.sequential.Rainbow_r, width=1000)

st.plotly_chart(fig_df_mul_bar_a)
roomtype_a = st.selectbox("Select the Room Type_a", df2_a["room_type"].unique()): Allows users to select a room type for further analysis.
df3_a = df2_a[df2_a["room_type"] == roomtype_a]: Filters the dataset based on the selected room type.
px.bar(...): Creates a grouped bar chart to compare availability across different time frames (30, 60, 90, and 365 days) based on host response time.

 Tab 3: Location Analysis
This tab focuses on analyzing Airbnb listings based on their location.

Setting Up the Layout and Loading Data:
with tab3:
    st.title("LOCATION ANALYSIS")
    st.write("")

    def datafr():
        df = pd.read_csv("C:/Users/dell/Airbnb Analysis/Airbnb.csv")
        return df

    df_l = datafr()
st.title("LOCATION ANALYSIS"): Sets the title for the third tab.
datafr() Function: Again loads the Airbnb dataset from the specified file path.

Selecting Country and Property Type for Location Analysis:
country_l = st.selectbox("Select the Country_l", df_l["country"].unique())
df1_l = df_l[df_l["country"] == country_l]
df1_l.reset_index(drop=True, inplace=True)

proper_ty_l = st.selectbox("Select the Property_type_l", df1_l["property_type"].unique())
df2_l = df1_l[df1_l["property_type"] == proper_ty_l]
df2_l.reset_index(drop=True, inplace=True)

st.selectbox("Select the Country_l", df_l["country"].unique()): Allows users to select a country for the location analysis.
df1_l = df_l[df_l["country"] == country_l]: Filters the dataset to include only the selected country.
st.selectbox("Select the Property_type_l", df1_l["property_type"].unique()): Allows users to select a property type within the selected country.
df2_l = df1_l[df1_l["property_type"] == proper_ty_l]: Filters the dataset further based on the selected property type.

Price Range Selection
The code allows users to select a price range for analyzing the Airbnb listings based on the distribution of prices.

Function to Filter Data by Price Range:
def select_the_df(sel_val):
    if sel_val == str(df2_l['price'].min()) + ' ' + str('to') + ' ' + str(differ_max_min * 0.30 + df2_l['price'].min()) + ' ' + str("(30% of the Value)"):
        df_val_30 = df2_l[df2_l["price"] <= differ_max_min * 0.30 + df2_l['price'].min()]
        df_val_30.reset_index(drop=True, inplace=True)
        return df_val_30

    elif sel_val == str(differ_max_min * 0.30 + df2_l['price'].min()) + ' ' + str('to') + ' ' + str(differ_max_min * 0.60 + df2_l['price'].min()) + ' ' + str("(30% to 60% of the Value)"):
        df_val_60 = df2_l[df2_l["price"] >= differ_max_min * 0.30 + df2_l['price'].min()]
        df_val_60_1 = df_val_60[df_val_60["price"] <= differ_max_min * 0.60 + df2_l['price'].min()]
        df_val_60_1.reset_index(drop=True, inplace=True)
        return df_val_60_1

    elif sel_val == str(differ_max_min * 0.60 + df2_l['price'].min()) + ' ' + str('to') + ' ' + str(df2_l['price'].max()) + ' ' + str("(60% to 100% of the Value)"):
        df_val_100 = df2_l[df2_l["price"] >= differ_max_min * 0.60 + df2_l['price'].min()]
        df_val_100.reset_index(drop=True, inplace=True)
        return df_val_100
select_the_df(sel_val): This function filters the dataset based on the selected price range:
If the selected value (sel_val) corresponds to 0-30% of the price range, it filters data accordingly.
For 30-60% and 60-100% price ranges, the dataset is similarly filtered.

Calculating the Price Difference:
differ_max_min = df2_l['price'].max() - df2_l['price'].min()
differ_max_min: Calculates the difference between the maximum and minimum prices in the filtered dataset.

Price Range Selection with Radio Buttons:
val_sel = st.radio("Select the Price Range", [
    str(df2_l['price'].min()) + ' ' + str('to') + ' ' + str(differ_max_min * 0.30 + df2_l['price'].min()) + ' ' + str("(30% of the Value)"),
    str(differ_max_min * 0.30 + df2_l['price'].min()) + ' ' + str('to') + ' ' + str(differ_max_min * 0.60 + df2_l['price'].min()) + ' ' + str("(30% to 60% of the Value)"),
    str(differ_max_min * 0.60 + df2_l['price'].min()) + ' ' + str('to') + ' ' + str(df2_l['price'].max()) + ' ' + str("(60% to 100% of the Value)")
])
df_val_sel = select_the_df(val_sel)
st.dataframe(df_val_sel)
st.radio(...): Displays radio buttons for selecting the desired price range.
select_the_df(val_sel): Filters the data based on the selected price range.
st.dataframe(df_val_sel): Displays the filtered dataframe within the Streamlit app.

Correlation Analysis
After filtering by price range, the code analyzes correlations between different numerical features in the dataset.

Correlation Matrix Calculation:
df_val_sel_corr = df_val_sel.drop(columns=["listing_url", "name", "property_type", "room_type", "bed_type", "cancellation_policy",
                                           "images", "host_url", "host_name", "host_location", "host_response_time", "host_thumbnail_url",
                                           "host_response_rate", "host_is_superhost", "host_has_profile_pic", "host_picture_url", "host_neighbourhood",
                                           "host_identity_verified", "host_verifications", "street", "suburb", "government_area", "market",
                                           "country", "country_code", "location_type", "is_location_exact", "amenities"]).corr()
st.dataframe(df_val_sel_corr)
df_val_sel.drop(columns=[...]).corr(): Calculates the correlation matrix after dropping non-numerical columns.
st.dataframe(df_val_sel_corr): Displays the correlation matrix in the Streamlit app.

Bar Charts for Data Grouping and Visualization
The code creates visualizations to analyze how various features like cleaning fees, bedrooms, beds, and extra people relate to the number of guests accommodated.

Grouped Bar Chart for Accommodations:
df_val_sel_gr = pd.DataFrame(df_val_sel.groupby("accommodates")[["cleaning_fee", "bedrooms", "beds", "extra_people"]].sum())
df_val_sel_gr.reset_index(inplace=True)

fig_1 = px.bar(df_val_sel_gr, x="accommodates", y=["cleaning_fee", "bedrooms", "beds"], title="ACCOMMODATES",
               hover_data="extra_people", barmode='group', color_discrete_sequence=px.colors.sequential.Rainbow_r, width=1000)
st.plotly_chart(fig_1)
df_val_sel.groupby("accommodates")[...].sum(): Groups data by the number of people the listing can accommodate and sums relevant features.
px.bar(...): Creates a grouped bar chart to visualize the relationship between accommodations and other features like cleaning fees, bedrooms, and beds.
st.plotly_chart(fig_1): Displays the bar chart in the Streamlit app.

Additional Bar Charts for Room Type and Government Area:
room_ty_l = st.selectbox("Select the Room_Type_l", df_val_sel["room_type"].unique())
df_val_sel_rt = df_val_sel[df_val_sel["room_type"] == room_ty_l]

fig_2 = px.bar(df_val_sel_rt, x=["street", "host_location", "host_neighbourhood"], y="market", title="MARKET",
               hover_data=["name", "host_name", "market"], barmode='group', orientation='h', color_discrete_sequence=px.colors.sequential.Rainbow_r, width=1000)
st.plotly_chart(fig_2)

fig_3 = px.bar(df_val_sel_rt, x="government_area", y=["host_is_superhost", "host_neighbourhood", "cancellation_policy"], title="GOVERNMENT_AREA",
               hover_data=["guests_included", "location_type"], barmode='group', color_discrete_sequence=px.colors.sequential.Rainbow_r, width=1000)
st.plotly_chart(fig_3)
fig_2: Visualizes market-related data based on room type and other features like street, host location, and neighborhood.
fig_3: Analyzes government area data, showing relationships with superhost status, neighborhood, and cancellation policy.

Tab 4: Geospatial Visualization
This tab focuses on the geographical distribution of Airbnb listings.
with tab4:
    st.title("GEOSPATIAL VISUALIZATION")
    st.write("")

    fig_4 = px.scatter_mapbox(df, lat='latitude', lon='longitude', color='price', size='accommodates',
                    color_continuous_scale= "rainbow", hover_name='name', range_color=(0, 49000), mapbox_style="carto-positron",
                    zoom=1)
    fig_4.update_layout(width=1150, height=800, title='Geospatial Distribution of Listings')
    st.plotly_chart(fig_4)
Geospatial Visualization with plotly:
px.scatter_mapbox: Creates a scatter plot on a map using latitude and longitude from the dataset.
lat and lon: Specifies the latitude and longitude for the map points.
color='price': Colors the points based on the price of the listings.
size='accommodates': Sizes the points based on how many people the listing can accommodate.
color_continuous_scale="rainbow": Applies a rainbow color scale to represent different price ranges.
hover_name='name': Shows the name of the listing when hovering over a point.
mapbox_style="carto-positron": Uses a specific map style for the background.
st.plotly_chart(fig_4): Displays the interactive map in the Streamlit app.

Tab 5: Country and Property Type Analysis
This tab allows users to explore Airbnb data by selecting a country and property type, and then viewing price-related visualizations.
with tab5:
    country_t = st.selectbox("Select the Country_t", df["country"].unique())

    df1_t = df[df["country"] == country_t]

    property_ty_t = st.selectbox("Select the Property_type_t", df1_t["property_type"].unique())

    df2_t = df1_t[df1_t["property_type"] == property_ty_t]
    df2_t.reset_index(drop=True, inplace=True)

    df2_t_sorted = df2_t.sort_values(by="price")
    df2_t_sorted.reset_index(drop=True, inplace=True)
Country and Property Type Filtering:
st.selectbox: Dropdowns are provided for users to select a country and a property type.
Filtering and Sorting: The dataset is filtered based on the selected country and property type, and then sorted by price.

Price Analysis by Neighborhood and Location
This section generates bar charts to analyze prices based on neighborhoods and host locations.
df_price = pd.DataFrame(df2_t_sorted.groupby("host_neighbourhood")["price"].agg(["sum", "mean"]))
df_price.reset_index(inplace=True)
df_price.columns = ["host_neighbourhood", "Total_price", "Avarage_price"]

col1, col2 = st.columns(2)

with col1:
    fig_price = px.bar(df_price, x="Total_price", y="host_neighbourhood", orientation='h',
                       title="PRICE BASED ON HOST_NEIGHBOURHOOD", width=600, height=800)
    st.plotly_chart(fig_price)

with col2:
    fig_price_2 = px.bar(df_price, x="Avarage_price", y="host_neighbourhood", orientation='h',
                         title="AVERAGE PRICE BASED ON HOST_NEIGHBOURHOOD", width=600, height=800)
    st.plotly_chart(fig_price_2)
Bar Charts for Host Neighborhood:

df_price.groupby("host_neighbourhood"): Groups the data by host neighborhood and calculates total and average prices.
px.bar: Creates horizontal bar charts to visualize total and average prices by neighborhood.
Similar Analysis for Host Location:

df_price_1 = pd.DataFrame(df2_t_sorted.groupby("host_location")["price"].agg(["sum", "mean"])): Similar grouping and bar chart creation is done for host locations.

Room Type Analysis
This section analyzes the top 100 listings by price for a selected room type.
room_type_t = st.selectbox("Select the Room_Type_t", df2_t_sorted["room_type"].unique())

df3_t = df2_t_sorted[df2_t_sorted["room_type"] == room_type_t]

df3_t_sorted_price = df3_t.sort_values(by="price")

df3_top_50_price = df3_t_sorted_price.head(100)

fig_top_50_price_1 = px.bar(df3_top_50_price, x="name", y="price", color="price",
                            color_continuous_scale="rainbow", range_color=(0, df3_top_50_price["price"].max()),
                            title="MINIMUM_NIGHTS MAXIMUM_NIGHTS AND ACCOMMODATES", width=1200, height=800,
                            hover_data=["minimum_nights", "maximum_nights", "accommodates"])

st.plotly_chart(fig_top_50_price_1)
Room Type and Top 100 Listings by Price:
st.selectbox: Dropdown for selecting a room type.
px.bar: Visualizes the top 100 listings by price, showing various features like minimum nights, maximum nights, and how many people the listing can accommodate.

About Section
This section provides an overview of the project, detailing the steps involved in data collection, cleaning, analysis, and visualization.if select == "About":
    st.header("ABOUT THIS PROJECT")

    st.subheader(":orange[1. Data Collection:]")
    st.write('''Gather data from Airbnb's public API or other available sources.
        Collect information on listings, hosts, reviews, pricing, and location data.''')

    st.subheader(":orange[2. Data Cleaning and Preprocessing:]")
    st.write('''Clean and preprocess the data to handle missing values, outliers, and ensure data quality.
        Convert data types, handle duplicates, and standardize formats.''')

    st.subheader(":orange[3. Exploratory Data Analysis (EDA):]")
    st.write('''***Conduct exploratory data analysis to understand the distribution and patterns in the data.
        Explore relationships between variables and identify potential insights.***''')

    st.subheader(":orange[4. Visualization:]")
    st.write('''***Create visualizations to represent key metrics and trends.
        Use charts, graphs, and maps to convey information effectively.
        Consider using tools like Matplotlib, Seaborn, or Plotly for visualizations.***''')

    st.subheader(":orange[5. Geospatial Analysis:]")
    st.write('''Utilize geospatial analysis to understand the geographical distribution of listings.
        Map out popular areas, analyze neighborhood characteristics, and visualize pricing variations.''')
Project Overview:
This section provides a step-by-step guide on how the project was conducted, from data collection to visualization.
The descriptions highlight the importance of each phase in the project, focusing on data integrity and effective communication of insights through visualizations.




